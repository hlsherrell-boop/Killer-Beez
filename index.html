<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Killer Beez</title>

<style>
  body {
    margin: 0;
    background: black;
    overflow: hidden;
    font-family: Arial, sans-serif;
  }

  canvas {
    display: block;
    background: black;
  }

  #scoreDisplay {
    position: absolute;
    color: white;
    font-size: 24px;
    top: 10px;
    left: 10px;
  }

  #pauseBtn {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 18px;
    padding: 6px 14px;
    cursor: pointer;
  }

  #playAgain {
    position: absolute;
    display: none;
    padding: 10px 22px;
    font-size: 22px;
    cursor: pointer;
    background: green;
    color: white;
    border: none;
    border-radius: 8px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, 50px);
  }
</style>
</head>

<body>

<canvas id="gameCanvas"></canvas>
<div id="scoreDisplay">Score: 0</div>
<button id="pauseBtn">Pause</button>
<button id="playAgain">Play Again</button>

<script>
/* ================= AUDIO ================= */
let audioCtx = null;
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playTone(freq, duration = 0.1, type = "square", volume = 0.15) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(volume, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

/* ================= SETUP ================= */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const scoreDisplay = document.getElementById("scoreDisplay");
const playAgainButton = document.getElementById("playAgain");
const pauseBtn = document.getElementById("pauseBtn");

let paused = false;
pauseBtn.onclick = () => {
  paused = !paused;
  pauseBtn.textContent = paused ? "Resume" : "Pause";
};

// Player
let snake = { x: canvas.width/2, y: canvas.height/2, radius: 30, speed: 5 };
let target = { x: snake.x, y: snake.y };

// Game state
let gameOver = false;
let score = 0;

// Bees
let bees = [];
let incomingBees = []; // white-dot warnings
let beeCount = 8;
const beeRadius = 25;

// Speed scaling
let beeSpeedMultiplier = 1;
let elapsedSeconds = 0;

// Slow orb
let slowOrb = null;
let slowTimer = 0;
let slowActive = false;

/* ================= BEE HELPERS ================= */
function spawnBee() {
  const margin = beeRadius + 5;
  let x, y;
  const edge = Math.random();
  if (edge < 0.25) { x = Math.random() * (canvas.width - 2*margin) + margin; y = margin; }
  else if (edge < 0.5) { x = canvas.width - margin; y = Math.random() * (canvas.height - 2*margin) + margin; }
  else if (edge < 0.75) { x = Math.random() * (canvas.width - 2*margin) + margin; y = canvas.height - margin; }
  else { x = margin; y = Math.random() * (canvas.height - 2*margin) + margin; }

  incomingBees.push({ x, y, timer: 2 }); // white-dot warning for new bees
}

function activateBee(bee) {
  const minSpeed = 1; // ensures bees move fast enough
  bees.push({
    x: bee.x,
    y: bee.y,
    radius: beeRadius,
    dx: (Math.random()*1.5 + minSpeed) * (Math.random()<0.5 ? 1 : -1),
    dy: (Math.random()*1.5 + minSpeed) * (Math.random()<0.5 ? 1 : -1)
  });
}

function createInitialBees() {
  bees = [];
  incomingBees = [];
  const margin = beeRadius + 5;
  for (let i = 0; i < beeCount; i++) {
    let x, y;
    const edge = Math.random();
    if (edge < 0.25) { x = Math.random() * (canvas.width - 2*margin) + margin; y = margin; }
    else if (edge < 0.5) { x = canvas.width - margin; y = Math.random() * (canvas.height - 2*margin) + margin; }
    else if (edge < 0.75) { x = Math.random() * (canvas.width - 2*margin) + margin; y = canvas.height - margin; }
    else { x = margin; y = Math.random() * (canvas.height - 2*margin) + margin; }

    const minSpeed = 1;
    bees.push({
      x, y, radius: beeRadius,
      dx: (Math.random()*1.5 + minSpeed) * (Math.random()<0.5 ? 1 : -1),
      dy: (Math.random()*1.5 + minSpeed) * (Math.random()<0.5 ? 1 : -1)
    });
  }
}
createInitialBees();

/* ================= INPUT ================= */
canvas.addEventListener("mousemove", e => {
  if (!gameOver && !paused) { target.x = e.clientX; target.y = e.clientY; }
});
canvas.addEventListener("mousedown", initAudio);
canvas.addEventListener("touchstart", initAudio, { passive: true });

/* ================= TIMERS ================= */
setInterval(() => {
  if (gameOver || paused) return;

  score++;
  elapsedSeconds++;
  scoreDisplay.textContent = "Score: " + score;

  if (elapsedSeconds % 30 === 0) {
    beeSpeedMultiplier += 0.1;
    spawnBee();
  }
}, 1000);

function scheduleSlowOrb() {
  const delay = Math.random()*90000 + 30000;
  setTimeout(() => {
    if (!gameOver && !slowOrb) {
      slowOrb = { x: Math.random()*canvas.width, y: Math.random()*canvas.height, radius: 12 };
      slowTimer = 5;
    }
    scheduleSlowOrb();
  }, delay);
}
scheduleSlowOrb();

/* ================= DRAW ================= */
function drawSnake() { ctx.fillStyle="lime"; ctx.beginPath(); ctx.arc(snake.x,snake.y,snake.radius,0,Math.PI*2); ctx.fill(); }
function drawBees() { ctx.fillStyle="yellow"; bees.forEach(b=>{ctx.beginPath(); ctx.arc(b.x,b.y,b.radius,0,Math.PI*2); ctx.fill();}); }
function drawIncomingBees() { ctx.fillStyle="white"; incomingBees.forEach(b=>{ctx.beginPath(); ctx.arc(b.x,b.y,10,0,Math.PI*2); ctx.fill();}); }
function drawSlowOrb() { if(!slowOrb) return; ctx.fillStyle="cyan"; ctx.beginPath(); ctx.arc(slowOrb.x,slowOrb.y,slowOrb.radius,0,Math.PI*2); ctx.fill(); }
function drawUI() { if(slowActive){ctx.fillStyle="cyan";ctx.font="18px Arial";ctx.fillText(`Slow: ${slowTimer}s`,canvas.width-140,50);} }

/* ================= UPDATE ================= */
function moveSnake() {
  const dx = target.x - snake.x;
  const dy = target.y - snake.y;
  const dist = Math.hypot(dx,dy);
  if(dist>1){snake.x += (dx/dist)*snake.speed; snake.y += (dy/dist)*snake.speed;}
}

function moveBees() {
  const slowFactor = slowActive ? 0.5 : 1;
  bees.forEach(b => {
    b.x += b.dx * beeSpeedMultiplier * slowFactor;
    b.y += b.dy * beeSpeedMultiplier * slowFactor;
    if (b.x < b.radius || b.x > canvas.width-b.radius) b.dx*=-1;
    if (b.y < b.radius || b.y > canvas.height-b.radius) b.dy*=-1;
  });

  for(let i=incomingBees.length-1;i>=0;i--){
    incomingBees[i].timer -= 1/60;
    if(incomingBees[i].timer <= 0){ activateBee(incomingBees[i]); incomingBees.splice(i,1); }
  }
}

function checkCollisions() {
  for(let b of bees){
    if(Math.hypot(snake.x-b.x,snake.y-b.y)<snake.radius+b.radius){ endGame(); return; }
  }
  if(slowOrb){
    const d = Math.hypot(snake.x-slowOrb.x,snake.y-slowOrb.y);
    if(d<snake.radius+slowOrb.radius){ slowOrb=null; slowActive=true; slowTimer=5; playTone(400,0.2); }
  }
}

function endGame(){
  gameOver=true; playTone(90,0.4,"sawtooth",0.3); playAgainButton.style.display="block";
}

function gameLoop(){
  requestAnimationFrame(gameLoop);
  if(paused||gameOver) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  moveSnake(); moveBees(); checkCollisions();
  drawSnake(); drawBees(); drawIncomingBees(); drawSlowOrb(); drawUI();
}
gameLoop();
</script>

</body>
</html>
